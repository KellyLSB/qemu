From: Kevin Wolf <kwolf@redhat.com>
Date: Wed, 26 Mar 2014 13:05:33 +0100
Subject: bochs: Check catalog_size header field (CVE-2014-0143)

It should neither become negative nor allow unbounded memory
allocations. This fixes aborts in g_malloc() and an s->catalog_bitmap
buffer overflow on big endian hosts.

Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
Reviewed-by: Max Reitz <mreitz@redhat.com>
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
(cherry picked from commit e3737b820b45e54b059656dc3f914f895ac7a88b)

Conflicts:
	block/bochs.c
	tests/qemu-iotests/078
	tests/qemu-iotests/078.out

diff --git a/block/bochs.c b/block/bochs.c
index 43c7260..30eb6e9 100644
--- a/block/bochs.c
+++ b/block/bochs.c
@@ -137,6 +137,13 @@ static int bochs_open(BlockDriverState *bs, int flags)
     }
 
     s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);
+    /* Limit to 1M entries to avoid unbounded allocation. This is what is
+     * needed for the largest image that bximage can create (~8 TB). */
+    if (s->catalog_size > 0x100000) {
+        fprintf(stderr, "Catalog size is too large\n");
+        goto fail;
+    }
+
     s->catalog_bitmap = g_malloc(s->catalog_size * 4);
     if (bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,
                    s->catalog_size * 4) != s->catalog_size * 4)
@@ -151,6 +158,11 @@ static int bochs_open(BlockDriverState *bs, int flags)
 
     s->extent_size = le32_to_cpu(bochs.extra.redolog.extent);
 
+    if (s->catalog_size < bs->total_sectors / s->extent_size) {
+        fprintf(stderr, "Catalog size is too small for this disk size\n");
+        goto fail;
+    }
+
     qemu_co_mutex_init(&s->lock);
     return 0;
  fail:
-- 
1.7.10.4

